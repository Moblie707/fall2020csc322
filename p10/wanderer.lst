     1                                  ; Will Baglivio
     2                                  ; 11/13/20
     3                                  ; CSC 323
     4                                  ; The Message Wanderer:
     5                                  ; This program lets a message wander like a snake in a confined screen.
     6                                  ; This code has been adapted from Dr. Allen's cycle.asm
     7                                  
     8                                  ;;; Define Structure for character on screen
     9                                  STRUC mStruct
    10 00000000 <res 00000002>          		RESB 2  ;;; space for <esc>[
    11 00000002 <res 00000002>          	.row:	RESB 2  ;;; two digit number (characters)
    12 00000004 <res 00000001>          		RESB 1  ;;; space for ;
    13 00000005 <res 00000002>          	.col:	RESB 2  ;;; two digit number (characters)
    14 00000007 <res 00000001>          		RESB 1  ;;; space for the H
    15 00000008 <res 00000001>          	.char:	RESB 1  ;;; space for THE character
    16                                  	.size:
    17                                  ENDSTRUC
    18                                  
    19                                  ;;; Calls itoa function
    20                                  ;;; Params(al has integer to convert, ebx has address of empty string)
    21                                  %macro callItoa 2
    22                                          pusha
    23                                          mov al, %1
    24                                          mov ebx, %2
    25                                  %%ybreak:
    26                                          call _itoa
    27                                  %%zbreak:
    28                                          popa
    29                                  %endmacro
    30                                  
    31                                  ;;; Prints a character
    32                                  ;;; Params (address of char)
    33                                  %macro printchar 1
    34                                  	pusha
    35                                  	mov eax, 4
    36                                  	mov ebx, 1
    37                                  	mov ecx, %1
    38                                  	mov edx, 9	;;; A character has 9 bytes
    39                                  	int 80h
    40                                  	popa
    41                                  %endmacro
    42                                  
    43                                  SECTION .data
    44                                  ; clear screen string
    45 00000000 1B5B324A                cls:		db 1bh,'[2J'
    46                                  
    47                                  ; Set cursor position control characters
    48 00000004 1B5B                    pos     db      1bh, '['
    49 00000006 3030                    row     db      '00'
    50 00000008 3B                              db      ';'
    51 00000009 3030                    col     db      '00'
    52 0000000B 48                              db      'H'
    53                                  
    54                                  ; Create an array of structs: formatted like the print interrupt uses.
    55 0000000C 1B5B31303B32384821      message:	db 1bh,'[10;28H!'
    56 00000015 1B5B31303B32374821      		db 1bh,'[10;27H!'
    57 0000001E 1B5B31303B32364873      		db 1bh,'[10;26Hs'
    58 00000027 1B5B31303B32354864      		db 1bh,'[10;25Hd'
    59 00000030 1B5B31303B3234486C      		db 1bh,'[10;24Hl'
    60 00000039 1B5B31303B32334872      		db 1bh,'[10;23Hr'
    61 00000042 1B5B31303B3232486F      		db 1bh,'[10;22Ho'
    62 0000004B 1B5B31303B32314857      		db 1bh,'[10;21HW'
    63 00000054 1B5B31303B32304820      		db 1bh,'[10;20H '
    64 0000005D 1B5B31303B3139486F      		db 1bh,'[10;19Ho'
    65 00000066 1B5B31303B3138486C      		db 1bh,'[10;18Hl'
    66 0000006F 1B5B31303B3137486C      		db 1bh,'[10;17Hl'
    67 00000078 1B5B31303B31364865      		db 1bh,'[10;16He'
    68 00000081 1B5B31303B31354848      		db 1bh,'[10;15HH'
    69                                  LEN: EQU 135
    70                                  messagelen: EQU 15
    71                                  
    72                                  ;;; Boundary character
    73 0000008A 1B5B30313B3430482A      community:	db 1bh,'[01;40H*'
    74                                  
    75                                  ;;; Boundary defined by community
    76                                  MINROW: EQU 1
    77                                  MAXROW: EQU 20
    78                                  MINCOL: EQU 1
    79                                  MAXCOL: EQU 40
    80                                  
    81                                  SECTION .bss
    82 00000000 <res 00000002>          emptystr:	RESB 2
    83                                  
    84                                  SECTION .text
    85                                  global _main, _clrscr, _itoa, _crcomm, _displayMessage, _setCursor
    86                                  _main:
    87 00000000 E81F000000              	call _clrscr	;;; Clears screen
    88 00000005 E844000000              	call _crcomm	;;; Creates community
    89                                  break:
    90 0000000A E876010000              	call _displayMessage
    91                                  
    92 0000000F B419                    	mov ah, 25
    93 00000011 B001                    	mov al, 1
    94 00000013 E896010000              	call _setCursor
    95                                  
    96                                  ; Demonstrate an infinite loop calling  functions which uses an array of structs
    97                                  
    98                                  ;top1: 	call	_displayMessage
    99                                  ;	call	_pause
   100                                  ;	call	_adjustMessage
   101                                  ;	jmp	top1
   102                                  
   103                                  
   104                                  
   105                                  ; Normal termination code
   106 00000018 B801000000              mov eax, 1
   107 0000001D BB00000000              mov ebx, 0
   108 00000022 CD80                    int 80h
   109                                  
   110                                  ;;; Clears screen
   111                                  _clrscr:
   112 00000024 60                              pusha
   113                                  
   114 00000025 B804000000                      mov eax, 4
   115 0000002A BB01000000                      mov ebx, 1
   116 0000002F B9[00000000]                    mov ecx, cls
   117 00000034 BA04000000                      mov edx, 4
   118 00000039 CD80                            int 80h
   119                                  
   120 0000003B 61                              popa
   121 0000003C C3                              ret
   122                                  
   123                                  ;;; Converts integer into string
   124                                  ;;; al has number (0 <= x < 100)
   125                                  ;;; ebx has address of string for storage
   126                                  _itoa:
   127 0000003D 60                              pusha
   128 0000003E 30E4                    	xor 	ah,ah
   129 00000040 B10A                            mov     cl,10
   130 00000042 F6F1                            div     cl
   131 00000044 80C430                          add     ah,'0'
   132 00000047 0430                            add     al,'0'
   133 00000049 668903                          mov     [ebx],ax
   134 0000004C 61                              popa
   135 0000004D C3                              ret
   136                                  
   137                                  ;;; Creates community
   138                                  _crcomm:
   139 0000004E 60                      	pusha
   140                                  	
   141                                  	;;; First prints top boundary
   142 0000004F B928000000              	mov ecx, MAXCOL
   143                                  	
   144                                  	top:
   145 00000054 51                      		push ecx
   146 00000055 49                      		dec ecx
   147                                  		printchar community				;;; Prints boundary character
   148 00000056 60                  <1>  pusha
   149 00000057 B804000000          <1>  mov eax, 4
   150 0000005C BB01000000          <1>  mov ebx, 1
   151 00000061 B9[8A000000]        <1>  mov ecx, %1
   152 00000066 BA09000000          <1>  mov edx, 9
   153 0000006B CD80                <1>  int 80h
   154 0000006D 61                  <1>  popa
   155                                  		callItoa cl, emptystr				;;; Convert current col to chars
   156 0000006E 60                  <1>  pusha
   157 0000006F 88C8                <1>  mov al, %1
   158 00000071 BB[00000000]        <1>  mov ebx, %2
   159                              <1> %%ybreak:
   160 00000076 E8C2FFFFFF          <1>  call _itoa
   161                              <1> %%zbreak:
   162 0000007B 61                  <1>  popa
   163 0000007C 668B1D[00000000]        		mov bx, [emptystr]
   164 00000083 881D[8F000000]          		mov BYTE [community + mStruct.col], bl		;;; Moves one column to the left
   165 00000089 883D[90000000]          		mov BYTE [community + mStruct.col + 1], bh
   166 0000008F 59                      		pop ecx
   167 00000090 E2C2                    		loop top
   168                                  
   169                                  	;;; Next, prints left boundary
   170 00000092 B901000000              	mov ecx, 1
   171                                  
   172                                  	left:
   173 00000097 83F914                  		cmp ecx, MAXROW					;;; Iterate over rows 1 <= x <= 20
   174 0000009A 7F3C                    		jg endleft
   175                                  
   176                                  		callItoa cl, emptystr				;;; Convert current row to chars
   177 0000009C 60                  <1>  pusha
   178 0000009D 88C8                <1>  mov al, %1
   179 0000009F BB[00000000]        <1>  mov ebx, %2
   180                              <1> %%ybreak:
   181 000000A4 E894FFFFFF          <1>  call _itoa
   182                              <1> %%zbreak:
   183 000000A9 61                  <1>  popa
   184 000000AA 668B1D[00000000]        		mov bx, [emptystr]
   185 000000B1 881D[8C000000]          		mov BYTE[community + mStruct.row], bl		;;; Moves one row down
   186 000000B7 883D[8D000000]          		mov BYTE[community + mStruct.row + 1], bh
   187                                  		printchar community				;;; Prints boundary character
   188 000000BD 60                  <1>  pusha
   189 000000BE B804000000          <1>  mov eax, 4
   190 000000C3 BB01000000          <1>  mov ebx, 1
   191 000000C8 B9[8A000000]        <1>  mov ecx, %1
   192 000000CD BA09000000          <1>  mov edx, 9
   193 000000D2 CD80                <1>  int 80h
   194 000000D4 61                  <1>  popa
   195                                  
   196 000000D5 41                      		inc ecx
   197 000000D6 EBBF                    		jmp left
   198                                  	endleft:
   199                                  
   200                                  	;;; Next, prints bottom boundary
   201 000000D8 B901000000              	mov ecx, 1
   202                                  
   203                                  	bottom:
   204 000000DD 83F928                  		cmp ecx, MAXCOL					;;; Iterate over cols 1 <= x <= 40
   205 000000E0 7F3C                    		jg endbottom
   206                                  
   207                                  		callItoa cl, emptystr				;;; Convert current col to chars
   208 000000E2 60                  <1>  pusha
   209 000000E3 88C8                <1>  mov al, %1
   210 000000E5 BB[00000000]        <1>  mov ebx, %2
   211                              <1> %%ybreak:
   212 000000EA E84EFFFFFF          <1>  call _itoa
   213                              <1> %%zbreak:
   214 000000EF 61                  <1>  popa
   215 000000F0 668B1D[00000000]        		mov bx, [emptystr]
   216 000000F7 881D[8F000000]          		mov BYTE[community + mStruct.col], bl		;;; Moves one col to the right
   217 000000FD 883D[90000000]          		mov BYTE[community + mStruct.col + 1], bh
   218                                  		printchar community				;;; Prints boundary character
   219 00000103 60                  <1>  pusha
   220 00000104 B804000000          <1>  mov eax, 4
   221 00000109 BB01000000          <1>  mov ebx, 1
   222 0000010E B9[8A000000]        <1>  mov ecx, %1
   223 00000113 BA09000000          <1>  mov edx, 9
   224 00000118 CD80                <1>  int 80h
   225 0000011A 61                  <1>  popa
   226                                  		
   227 0000011B 41                      		inc ecx
   228 0000011C EBBF                    		jmp bottom
   229                                  	endbottom:
   230                                  
   231                                  	;;; Finally, prints right boundary
   232 0000011E B914000000              	mov ecx, MAXROW
   233                                  
   234                                  	right:
   235 00000123 51                      		push ecx
   236 00000124 49                      		dec ecx
   237                                  		printchar community				;;; Prints boundary character
   238 00000125 60                  <1>  pusha
   239 00000126 B804000000          <1>  mov eax, 4
   240 0000012B BB01000000          <1>  mov ebx, 1
   241 00000130 B9[8A000000]        <1>  mov ecx, %1
   242 00000135 BA09000000          <1>  mov edx, 9
   243 0000013A CD80                <1>  int 80h
   244 0000013C 61                  <1>  popa
   245                                  		callItoa cl, emptystr				;;; Convert current row to chars
   246 0000013D 60                  <1>  pusha
   247 0000013E 88C8                <1>  mov al, %1
   248 00000140 BB[00000000]        <1>  mov ebx, %2
   249                              <1> %%ybreak:
   250 00000145 E8F3FEFFFF          <1>  call _itoa
   251                              <1> %%zbreak:
   252 0000014A 61                  <1>  popa
   253 0000014B 668B1D[00000000]        		mov bx, [emptystr]
   254 00000152 881D[8C000000]          		mov BYTE[community + mStruct.row], bl		;;; Moves one row up
   255 00000158 883D[8D000000]          		mov BYTE[community + mStruct.row + 1], bh
   256 0000015E 59                      		pop ecx
   257 0000015F E2C2                    		loop right
   258                                  
   259 00000161 61                      	popa
   260 00000162 C3                      	ret
   261                                  
   262                                  ;;;;;;;;;;;;  Function that rotates the characters through the array of structs 
   263                                  _adjustMessage:	
   264 00000163 60                      	pusha
   265                                  
   266 00000164 A0[14000000]            	mov	al, BYTE [message + mStruct.char] ;; get first char to put at bottom
   267 00000169 50                      	push	eax   ; save for bottom
   268                                  
   269 0000016A BB[0C000000]            	mov	ebx,message  ;; pointer into array, starting at top
   270 0000016F B986000000              	mov	ecx,LEN-1    ;; loop 
   271                                  
   272 00000174 8A5311                  _amTop: mov	dl,[ebx + mStruct.size + mStruct.char] 	;; get char below
   273 00000177 885308                  	mov	[ebx + mStruct.char],dl			;; put on current row
   274                                  
   275 0000017A 83C309                  	add	ebx,mStruct.size
   276 0000017D E2F5                    	loop	_amTop
   277                                  
   278 0000017F 58                      	pop	eax	;; retreive the first char
   279 00000180 884308                  	mov	BYTE [ebx + mStruct.char],al
   280                                  
   281 00000183 61                      	popa
   282 00000184 C3                      	ret
   283                                  
   284                                  
   285                                  ;;;;;;;;;;;   Function to print the array of structs of message
   286                                  _displayMessage:
   287 00000185 60                      	pusha
   288 00000186 BB[0C000000]            	mov	ebx,message
   289 0000018B B90F000000              	mov	ecx,messagelen
   290                                  
   291 00000190 51                      _dmTop:	push	ecx
   292 00000191 53                      	push	ebx
   293 00000192 B804000000              	mov	eax,4  ; system print
   294 00000197 89D9                    	mov	ecx,ebx ; points to string to print
   295 00000199 BB01000000              	mov	ebx,1   ; standard out
   296 0000019E BA09000000              	mov	edx,9   ; num chars to print
   297 000001A3 CD80                    	int	80h
   298                                  
   299 000001A5 5B                      	pop	ebx
   300 000001A6 83C309                  	add	ebx,mStruct.size
   301 000001A9 59                      	pop	ecx
   302 000001AA E2E4                    	loop	_dmTop
   303 000001AC 61                      	popa
   304 000001AD C3                      	ret
   305                                  
   306                                  ;. _setcursor expects AH = row, AL = col
   307                                  _setCursor:
   308 000001AE 60                              pusha
   309                                          ;;; save original to get col later
   310 000001AF 50                              push    eax
   311                                          ;;;;;; process row
   312 000001B0 66C1E808                        shr     ax,8    ;; shift row to right
   313 000001B4 B30A                            mov     bl,10
   314 000001B6 F6F3                            div     bl      ;; puts ax/10 in al, remainder in ah
   315 000001B8 80C430                          add     ah,'0'
   316 000001BB 0430                            add     al,'0'
   317 000001BD A2[06000000]                    mov     BYTE [row],al
   318 000001C2 8825[07000000]                  mov     BYTE [row+1],ah
   319                                          ;;;; process col
   320 000001C8 58                              pop     eax     ;; restore original parms
   321 000001C9 6625FF00                        and     ax,0FFh ;; erase row, leave col
   322 000001CD B30A                            mov     bl,10
   323 000001CF F6F3                            div     bl      ;; puts ax/10 in al, remainder in ah
   324 000001D1 80C430                          add     ah,'0'
   325 000001D4 0430                            add     al,'0'
   326 000001D6 A2[09000000]                    mov     BYTE [col],al
   327 000001DB 8825[0A000000]                  mov     BYTE [col+1],ah
   328                                  
   329                                          ;;;;; now print the set cursor codes
   330 000001E1 B804000000                      mov     eax,4
   331 000001E6 BB01000000                      mov     ebx,1
   332 000001EB B9[04000000]                    mov     ecx,pos
   333 000001F0 BA08000000                      mov     edx,8
   334 000001F5 CD80                            int     80h
   335                                  
   336 000001F7 61                              popa
   337 000001F8 C3                              ret
   338                                  
   339                                  ;;;;;;;;;;;;;  Function to sleep 1/20 second ;;;;;;;;;;;;;;;;;;;;;
   340                                  _pause: 
   341 000001F9 60                      	pusha
   342 000001FA B8A2000000              	mov	eax,162
   343 000001FF BB[0D020000]            	mov	ebx,seconds
   344 00000204 B900000000              	mov	ecx,0
   345 00000209 CD80                    	int	80h
   346 0000020B 61                      	popa
   347 0000020C C3                      	ret
   348                                  
   349                                  ;;;;;;;;;;;;	Tricky use of ram.... put some data here for _pause to use
   350 0000020D 0000000080F0FA02        seconds: dd	0,50000000  ;;;  seconds, nanoseconds
   351                                  
   352                                  
